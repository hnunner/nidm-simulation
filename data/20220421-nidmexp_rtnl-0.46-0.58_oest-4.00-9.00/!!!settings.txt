ep.setC2(0.05714);		// 7ties

double[] rationalities = {0.46, 0.47, 0.48, 0.49, 0.50, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58};
double[] overestimates = {4.00, 4.25, 4.50, 4.75, 5.00, 5.25, 5.50, 5.75, 6.0, 6.25, 6.50, 6.75, 7.0, 7.50, 8.0, 9.0};



---->>> best match: rtnl: 0.47 & oest: 8.0





boolean sameRationalities = false;
double[] rationalitiesInfectedNeighbor = {1.00};

// expected average risk score and standard deviation - taken from NIDM experiment and
// rescaled to range between 0.0 and 2.0: 
// > mean(d.users$r_score)
// [1] 13.03264
// > convert_risk_score_from_experiment(13.03264)
// [1] 1.223701
// > sd(d.users$r_score)
//[1] 5.863769
// > convert_risk_score_from_experiment(13.03264) - convert_risk_score_from_experiment(5.863769)
// [1] -0.4625078
// > 1.223701 - (2-1.223701)
// [1] 0.447402
double meanRiskScore = 1.223701;
NormalDistribution nd = new NormalDistribution(meanRiskScore, 0.4625078);
double riskScore = -1.0;
while (riskScore > 2.0 || riskScore < 0.447402) {
    riskScore = nd.sample();
}
riskScores.add(riskScore);


// make proportion of 0.86 agents irrational (trying to have 12+ ties) :: 0.02 == 20 ties optimal :: 0.8597222 == proportion of participants with irr_rounds > 0
if (ThreadLocalRandom.current().nextDouble() >= 0.8597222) {
	agent.updateUtilityFunction(new NunnerBuskens(ump.getB1(),ump.getB2(), ump.getAlpha(), ump.getC1(), 0.02, ump.getOverestimate()));
}

> nrow(d.users %>% dplyr::filter(irr_rounds > 0))
[1] 404
> 1- 404 /2880
[1] 0.8597222